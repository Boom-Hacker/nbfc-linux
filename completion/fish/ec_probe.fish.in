# This script was generated by argparse-shell-complete.
# argparse-shell-complete: A tool that creates robust and reliable autocompletion scripts using Python's argparse module.
# For more information, visit: https://github.com/argparse-shell-complete/argparse-shell-complete

function _ec_probe_command
  printf "%s\t%s\n" \
    dump 'Dump all EC registers' \
    load 'Load a previously made dump into the embedded controller' \
    read 'Read a byte from a EC register' \
    write 'Write a byte to a EC register' \
    monitor 'Monitor all EC registers for changes' \
    watch 'Monitor all EC registers for changes (alternative version'
end

function _ec_probe_fish_helper
  # ===========================================================================
  #
  # This function implements the parsing of options and positionals in the Fish shell.
  #
  # Usage: __fish_helper <OPTIONS> <COMMAND> [ARGS...]
  #
  # The first argument is a comma-seperated list of options that the parser should know about.
  # Short options (-o), long options (--option), and old-style options (-option) are supported.
  #
  # If an option takes an argument, it is suffixed by '='.
  # If an option takes an optional argument, it is suffixed by '=?'.
  #
  # For example:
  #   __fish_helper '-f,--flag,-old-style,--with-arg=,--with-optional=?'
  #
  #   Here, -f, --flag and -old-style don't take options, --with-arg requires an
  #   argument and --with-optional takes an optional argument.
  #
  # COMMANDS
  #   positional_contains <NUM> <WORDS...>
  #     Checks if the positional argument number NUM is one of WORDS.
  #     NUM counts from one.
  #
  #   has_option <OPTIONS...>
  #     Checks if a option given in OPTIONS is passed on commandline.
  #
  #   num_of_positionals [<OPERATOR> <NUMBER>]
  #     Checks the number of positional arguments.
  #     If no arguments are provided, print the total count of positional arguments.
  #     If two arguments are provided, the first argument should be one of
  #     the comparison operators: '-lt', '-le', '-eq', '-ne', '-gt', '-ge'.
  #     Returns 0 if the count of positional arguments matches the
  #     specified NUMBER according to the comparison operator, otherwise returns 1.
  #
  # ===========================================================================

  set -l func '__fish_helper'

  set -l short_opts_with_arg
  set -l long_opts_with_arg
  set -l old_opts_with_arg

  set -l short_opts_without_arg
  set -l long_opts_without_arg
  set -l old_opts_without_arg

  set -l short_opts_with_optional_arg
  set -l long_opts_with_optional_arg
  set -l old_opts_with_optional_arg

  set -l option

  # ===========================================================================
  # Parsing of OPTIONS argument
  # ===========================================================================

  if test (count $argv) -lt 1
    echo "$func: missing OPTIONS argument" >&2
    return 1
  end

  if test -n "$argv[1]"
    for option in (string split -- ',' $argv[1])
      # Using one big switch case is the fastest way
      switch $option
        case '--?*=';   set -a long_opts_with_arg           (string replace -- '='  '' $option)
        case '--?*=\?'; set -a long_opts_with_optional_arg  (string replace -- '=?' '' $option)
        case '--?*';    set -a long_opts_without_arg        $option

        case '-?=';     set -a short_opts_with_arg          (string replace -- '='  '' $option)
        case '-?=\?';   set -a short_opts_with_optional_arg (string replace -- '=?' '' $option)
        case '-?';      set -a short_opts_with_arg          $option

        case '-??*=';   set -a old_opts_with_arg            (string replace -- '='  '' $option)
        case '-??*=\?'; set -a old_opts_with_optional_arg   (string replace -- '=?' '' $option)
        case '-??*';    set -a old_opts_without_arg         $option

        case '*'
          echo "$func: argv[1]: '$option' is not a short, long or old-style option" >&2
          return 1
      end
    end
  end

  set -e argv[1]

  # ===========================================================================
  # Parsing of options and positionals
  # ===========================================================================

  set -l positionals
  set -l having_options

  set -l cmdline (commandline -poc)
  set -l cmdline_count (count $cmdline)

  set -l argi 2 # cmdline[1] is command name
  while test $argi -le $cmdline_count
    set -l arg "$cmdline[$argi]"
    set -l have_trailing_arg (test $argi -lt $cmdline_count && echo true || echo false)

    switch $arg
      case '-'
        set -a positionals -
      case '--'
        for argi in (seq (math $argi + 1) $cmdline_count)
          set -a positionals $cmdline[$argi]
        end
        break
      case '--*'
        for option in $long_opts_with_arg $long_opts_without_arg $long_opts_with_optional_arg
          if string match -q -- "$option=*" $arg
            set -a having_options $option
            break
          else if string match -q -- $option $arg
            if contains -- $option $long_opts_with_arg
              if $have_trailing_arg
                set -a having_options $option
                set argi (math $argi + 1)
              end
            else
              set -a having_options $option
            end
            break
          end
        end
      case '-*'
        set -l have_match false

        for option in $old_opts_with_arg $old_opts_without_arg $old_opts_with_optional_arg
          if string match -q -- "$option=*" $arg
            set -a having_options $option
            set have_match true
            break
          else if string match -q -- $option $arg
            if contains -- $option $old_opts_with_arg
              if $have_trailing_arg
                set -a having_options $option
                set argi (math $argi + 1)
              end
            else
              set -a having_options $option
            end

            set have_match true
            break
          end
        end

        if not $have_match
          set -l arg_length (string length -- $arg)
          set -l i 2
          set is_end false
          while not $is_end && test $i -le $arg_length
            set -l char (string sub -s $i -l 1 -- "$arg")
            set -l have_trailing_chars (test $i -lt $arg_length && echo true || echo false)

            for option in $short_opts_with_arg $short_opts_without_arg $short_opts_with_optional_arg
              set -l option_char (string sub -s 2 -l 1 -- $option)

              if test "$char" = "$option_char"
                if contains -- $option $short_opts_with_arg
                  if $have_trailing_chars
                    set -a having_options $option
                    set is_end true
                  else if $have_trailing_arg
                    set -a having_options $option
                    set argi (math $argi + 1)
                    set is_end true
                  end
                else if contains -- $option $short_opts_with_optional_arg
                  set -a having_options $option

                  if $have_trailing_chars
                    set is_end true
                  end
                else
                  set -a having_options $option
                end

                break
              end
            end

            set i (math $i + 1)
          end
        end
      case '*'
        set -a positionals $arg
    end

    set argi (math $argi + 1)
  end

  # ===========================================================================
  # Commands
  # ===========================================================================

  if test (count $argv) -eq 0
    echo "$func: missing command" >&2
    return 1
  end

  set -l cmd "$argv[1]"
  set -e argv[1]

  switch $cmd
    case 'positional_contains'
      if test (count $argv) -eq 0
        echo "$func: positional_contains: argv[3]: missing number" >&2
        return 1
      end

      set -l positional_num $argv[1]
      set -e argv[1]
      contains -- $positionals[$positional_num] $argv && return 0 || return 1
    case 'has_option'
      for option in $having_options
        contains -- $option $argv && return 0
      end

      return 1
    case 'num_of_positionals'
      if test (count $argv) -eq 0
        count $positionals
      else if test (count $argv) -eq 2
        if contains -- $argv[1] -lt -le -eq -ne -gt -ge;
          test (count $positionals) $argv[1] $argv[2] && return 0 || return 1
        else
          echo "$func: num_of_positionals: $argv[1]: unknown operator" >&2
          return 1
        end
      else if test (count $argv) -eq 1
        echo "$func: num_of_positionals: $argv[1]: missing operand" >&2
        return 1
      end
    case '*'
      echo "$func: argv[2]: invalid command" >&2
      return 1
  end
end

set -l prog "ec_probe"
set -l helper "_ec_probe_fish_helper"

# command ec_probe
set -l options "--help,-h,-e=,--embedded-controller="
set -l guard000 "not $helper '$options' has_option --help -h && $helper '$options' num_of_positionals -eq 0"
set -l guard001 "not $helper '$options' has_option -e --embedded-controller && $helper '$options' num_of_positionals -eq 0"
set -l guard002 "$helper '$options' num_of_positionals -eq 0"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s e -l embedded-controller -d 'Specify embedded controller to use' -x -a 'acpi_ec ec_sys dev_port'
complete -c $prog -n $guard002 -d Commands -f -a '(_ec_probe_command)'

# command ec_probe dump
set -l options "--help,-h,-e=,--embedded-controller=,--help,-h,-c,--color,-C,--no-color"
set -l guard000 "$helper '$options' positional_contains 1 dump && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 dump && not $helper '$options' has_option -c --color"
set -l guard002 "$helper '$options' positional_contains 1 dump && not $helper '$options' has_option -C --no-color"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s c -l color -d 'Force colored output' -f
complete -c $prog -n $guard002 -s C -l no-color -d 'Disable colored output' -f

# command ec_probe load
set -l options "--help,-h,-e=,--embedded-controller=,--help,-h"
set -l guard000 "$helper '$options' positional_contains 1 load && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 load && $helper '$options' num_of_positionals -eq 1"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -r -F

# command ec_probe read
set -l options "--help,-h,-e=,--embedded-controller=,--help,-h,-w,--word"
set -l guard000 "$helper '$options' positional_contains 1 read && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 read && not $helper '$options' has_option -w --word"
set -l guard002 "$helper '$options' positional_contains 1 read && $helper '$options' num_of_positionals -eq 1"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s w -l word -d 'Combine two registers into one' -f
complete -c $prog -n $guard002 -d 'Register source' -x -a '(seq 0 255)'

# command ec_probe write
set -l options "--help,-h,-e=,--embedded-controller=,--help,-h,-w,--word"
set -l guard000 "$helper '$options' positional_contains 1 write && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 write && not $helper '$options' has_option -w --word"
set -l guard002 "$helper '$options' positional_contains 1 write && $helper '$options' num_of_positionals -eq 1"
set -l guard003 "$helper '$options' positional_contains 1 write && $helper '$options' num_of_positionals -eq 2"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s w -l word -d 'Combine two registers into one' -f
complete -c $prog -n $guard002 -d 'Register destination' -x -a '(seq 0 255)'
complete -c $prog -n $guard003 -d 'Value to write' -x

# command ec_probe monitor
set -l options "--help,-h,-e=,--embedded-controller=,--help,-h,-i=,--interval=,-t=,--timespan=,-r=,--report=,-c,--clearly,-d,--decimal"
set -l guard000 "$helper '$options' positional_contains 1 monitor && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 monitor && not $helper '$options' has_option -i --interval"
set -l guard002 "$helper '$options' positional_contains 1 monitor && not $helper '$options' has_option -t --timespan"
set -l guard003 "$helper '$options' positional_contains 1 monitor && not $helper '$options' has_option -r --report"
set -l guard004 "$helper '$options' positional_contains 1 monitor && not $helper '$options' has_option -c --clearly"
set -l guard005 "$helper '$options' positional_contains 1 monitor && not $helper '$options' has_option -d --decimal"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s i -l interval -d 'Monitored timespan' -x
complete -c $prog -n $guard002 -s t -l timespan -d 'Set poll intervall' -x
complete -c $prog -n $guard003 -s r -l report -d 'Save all readings as a CSV file' -r -F
complete -c $prog -n $guard004 -s c -l clearly -d 'Blanks out consecutive duplicate readings' -f
complete -c $prog -n $guard005 -s d -l decimal -d 'Output readings in decimal format instead of hexadecimal format' -f

# command ec_probe watch
set -l options "--help,-h,-e=,--embedded-controller=,--help,-h,-i=,--interval=,-t=,--timespan="
set -l guard000 "$helper '$options' positional_contains 1 watch && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 watch && not $helper '$options' has_option -i --interval"
set -l guard002 "$helper '$options' positional_contains 1 watch && not $helper '$options' has_option -t --timespan"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s i -l interval -d 'Sets the update interval in seconds' -x
complete -c $prog -n $guard002 -s t -l timespan -d 'Sets how many seconds the program will run' -x

# vim: ft=fish ts=2 sts=2 sw=2 et
