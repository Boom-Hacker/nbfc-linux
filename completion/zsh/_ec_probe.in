#compdef ec_probe

# This script was generated by argparse-shell-complete.
# argparse-shell-complete: A tool that creates robust and reliable autocompletion scripts using Python's argparse module.
# For more information, visit: https://github.com/argparse-shell-complete/argparse-shell-complete

_ec_probe_get_positional() {
  local FUNC='get_positional'
  local CONTAINS="${FUNC}_contains"

  $CONTAINS() {
  local ARG KEY="$1"; shift
  for ARG; do [[ "$KEY" == "$ARG" ]] && return 0; done
  return 1
  }

  local IFS=','
  local -a OPTIONS=(${=1})
  local WANTED_POSITIONAL=$2
  unset IFS
  shift 2

  local -a   OLD_OPTS_WITH_ARG   OLD_OPTS_WITH_OPTIONAL_ARG   OLD_OPTS_WITHOUT_ARG
  local -a  LONG_OPTS_WITH_ARG  LONG_OPTS_WITH_OPTIONAL_ARG  LONG_OPTS_WITHOUT_ARG
  local -a SHORT_OPTS_WITH_ARG SHORT_OPTS_WITH_OPTIONAL_ARG SHORT_OPTS_WITHOUT_ARG

  local OPTION
  for OPTION in "${OPTIONS[@]}"; do
  case "$OPTION" in
    (--?*=)    LONG_OPTS_WITH_ARG+=("${OPTION//=/}");;
    (--?*=\?)  LONG_OPTS_WITH_OPTIONAL_ARG+=("${OPTION//=?/}");;
    (--?*);    LONG_OPTS_WITHOUT_ARG+=("$OPTION");;

    (-?=)      SHORT_OPTS_WITH_ARG+=("${OPTION//=/}");;
    (-?=\?)    SHORT_OPTS_WITH_OPTIONAL_ARG+=("${OPTION//=?/}");;
    (-?)       SHORT_OPTS_WITHOUT_ARG+=("$OPTION");;

    (-??*=)    OLD_OPTS_WITH_ARG+=("${OPTION//=/}");;
    (-??*=\?)  OLD_OPTS_WITH_OPTIONAL_ARG+=("${OPTION//=?/}");;
    (-??*)     OLD_OPTS_WITHOUT_ARG+=("$OPTION");;

    (*) echo "$FUNC: $OPTION: not a valid short, long or oldstyle option" >&2; return 1;;
  esac
  done

  local -a POSITIONALS
  local -a HAVING_OPTIONS

  local ARGI=2 # ARG[1] is program name
  while [[ $ARGI -le $# ]]; do
  local ARG="${@[$ARGI]}"
  local HAVE_TRAILING_ARG=$(test $ARGI -lt $# && echo true || echo false)

  case "$ARG" in
    (-)
      POSITIONALS+=(-);;
    (--)
      for ARGI in $(seq $((ARGI + 1)) $#); do
        POSITIONALS+=("${@[$ARGI]}")
      done
      break;;
    (--*)
      for OPTION in $LONG_OPTS_WITH_ARG $LONG_OPTS_WITHOUT_ARG $LONG_OPTS_WITH_OPTIONAL_ARG; do
        if [[ "$ARG" == "$OPTION="* ]]; then
          HAVING_OPTIONS+=("$OPTION")
          break
        elif [[ "$ARG" == "$OPTION" ]]; then
          if $CONTAINS "$OPTION" "${LONG_OPTS_WITH_ARG[@]}"; then
            if $HAVE_TRAILING_ARG; then
              HAVING_OPTIONS+=("$OPTION")
              (( ARGI++ ))
            fi
          else
            HAVING_OPTIONS+=("$OPTION")
          fi
          break
        fi
      done;;
    (-*)
      local HAVE_MATCH=false

      for OPTION in $OLD_OPTS_WITH_ARG $OLD_OPTS_WITHOUT_ARG $OLD_OPTS_WITH_OPTIONAL_ARG; do
        if [[ "$ARG" == "$OPTION="* ]]; then
          HAVING_OPTIONS+=("$OPTION")
          HAVE_MATCH=true
          break
        elif [[ "$ARG" == "$OPTION" ]]; then
          if $CONTAINS "$OPTION" "${OLD_OPTS_WITH_ARG[@]}"; then
            if $HAVE_TRAILING_ARG; then
              HAVING_OPTIONS+=("$OPTION")
              (( ARGI++ ))
            fi
          else
            HAVING_OPTIONS+=("$OPTION")
          fi

          HAVE_MATCH=true
          break
        fi
      done

      if ! $HAVE_MATCH; then
        local ARG_LENGTH=${#ARG}
        local I=1
        local IS_END=false
        while ! $IS_END && test $I -lt $ARG_LENGTH; do
          local ARG_CHAR="${ARG:$I:1}"
          local HAVE_TRAILING_CHARS=$(test $((I+1)) -lt $ARG_LENGTH && echo true || echo false)

          for OPTION in $SHORT_OPTS_WITH_ARG $SHORT_OPTS_WITHOUT_ARG $SHORT_OPTS_WITH_OPTIONAL_ARG; do
            local OPTION_CHAR="${OPTION:1:1}"

            if test "$ARG_CHAR" = "$OPTION_CHAR"; then
              if $CONTAINS "$OPTION" "${SHORT_OPTS_WITH_ARG[@]}"; then
                if $HAVE_TRAILING_CHARS; then
                  HAVING_OPTIONS+=("$OPTION")
                  IS_END=true
                elif $HAVE_TRAILING_ARG; then
                  HAVING_OPTIONS+=("$OPTION")
                  (( ARGI++ ))
                  IS_END=true
                fi
              elif $CONTAINS "$OPTION" "${SHORT_OPTS_WITH_OPTIONAL_ARG[@]}"; then
                HAVING_OPTIONS+=("$OPTION")

                if $HAVE_TRAILING_CHARS; then
                  IS_END=true
                fi
              else
                HAVING_OPTIONS+=("$OPTION")
              fi

              break
            fi
          done

          (( I++ ))
        done
      fi;;
    (*)
      POSITIONALS+=("$ARG");;
  esac

  (( ARGI++ ))
  done

  if test $WANTED_POSITIONAL -eq 0; then
  echo "$FUNC: argv[2]: positionals start at 1, not 0!" >&2
  return 1
  fi

  printf "%s" "${POSITIONALS[$WANTED_POSITIONAL]}"
}

_ec_probe_command() {
  local -a DESCRIBE=(
    dump:'Dump all EC registers'
    load:'Load a previously made dump into the embedded controller'
    read:'Read a byte from a EC register'
    write:'Write a byte to a EC register'
    monitor:'Monitor all EC registers for changes'
    watch:'Monitor all EC registers for changes (alternative version'
  )

  _describe -- command DESCRIBE
}

_ec_probe() {
  # We have to check for subcommands here, because _arguments modifies $words
  local opts="--help,-h,-e=,--embedded-controller="
  case "$(_ec_probe_get_positional "$opts" 1 "${words[@]}")" in
    (dump) _ec_probe_dump; return $?;;
    (load) _ec_probe_load; return $?;;
    (read) _ec_probe_read; return $?;;
    (write) _ec_probe_write; return $?;;
    (monitor) _ec_probe_monitor; return $?;;
    (watch) _ec_probe_watch; return $?;;
  esac

  local -a arguments=(
    '(--help -h)'{--help,-h}'[show this help message and exit]'::' '
    '(--embedded-controller -e)'{--embedded-controller=,-e+}'[Specify embedded controller to use]':EC:'(acpi_ec ec_sys dev_port)'
    1:command1:_ec_probe_command
  )

  _arguments -S "${arguments[@]}"
}

_ec_probe_dump() {
  local -a arguments=(
    '(--help -h)'{--help,-h}'[show this help message and exit]'::' '
    '(--color -c)'{--color,-c}'[Force colored output]'::' '
    '(--no-color -C)'{--no-color,-C}'[Disable colored output]'::' '
    1:command1:_ec_probe_command
  )

  _arguments -S "${arguments[@]}"
}

_ec_probe_load() {
  local -a arguments=(
    '(--help -h)'{--help,-h}'[show this help message and exit]'::' '
    1:command1:_ec_probe_command
    2:' ':_files
  )

  _arguments -S "${arguments[@]}"
}

_ec_probe_read() {
  local -a arguments=(
    '(--help -h)'{--help,-h}'[show this help message and exit]'::' '
    '(--word -w)'{--word,-w}'[Combine two registers into one]'::' '
    1:command1:_ec_probe_command
    2:'Register source':'({0..255})'
  )

  _arguments -S "${arguments[@]}"
}

_ec_probe_write() {
  local -a arguments=(
    '(--help -h)'{--help,-h}'[show this help message and exit]'::' '
    '(--word -w)'{--word,-w}'[Combine two registers into one]'::' '
    1:command1:_ec_probe_command
    2:'Register destination':'({0..255})'
    3:'Value to write':' '
  )

  _arguments -S "${arguments[@]}"
}

_ec_probe_monitor() {
  local -a arguments=(
    '(--help -h)'{--help,-h}'[show this help message and exit]'::' '
    '(--interval -i)'{--interval=,-i+}'[Monitored timespan]':seconds:' '
    '(--timespan -t)'{--timespan=,-t+}'[Set poll intervall]':seconds:' '
    '(--report -r)'{--report=,-r+}'[Save all readings as a CSV file]':REPORT:_files
    '(--clearly -c)'{--clearly,-c}'[Blanks out consecutive duplicate readings]'::' '
    '(--decimal -d)'{--decimal,-d}'[Output readings in decimal format instead of hexadecimal format]'::' '
    1:command1:_ec_probe_command
  )

  _arguments -S "${arguments[@]}"
}

_ec_probe_watch() {
  local -a arguments=(
    '(--help -h)'{--help,-h}'[show this help message and exit]'::' '
    '(--interval -i)'{--interval=,-i+}'[Sets the update interval in seconds]':seconds:' '
    '(--timespan -t)'{--timespan=,-t+}'[Sets how many seconds the program will run]':seconds:' '
    1:command1:_ec_probe_command
  )

  _arguments -S "${arguments[@]}"
}

_ec_probe "$@"

# vim: ft=zsh ts=2 sts=2 sw=2 et
